<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学习博客</title>
  
  <subtitle>有志者事竟成</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fatesx.gitee.io/blog/"/>
  <updated>2018-12-28T09:48:32.075Z</updated>
  <id>http://fatesx.gitee.io/blog/</id>
  
  <author>
    <name>fate</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开发环境搭建</title>
    <link href="http://fatesx.gitee.io/blog/2018/04/01/190-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://fatesx.gitee.io/blog/2018/04/01/190-开发环境搭建/</id>
    <published>2018-04-01T05:23:50.000Z</published>
    <updated>2018-12-28T09:48:32.075Z</updated>
    
    <content type="html"><![CDATA[<p>现整理了项目开发所需的环境搭建教程，可参考下文配置开发环境，示例为windows环境下的教程，其他环境请自行调整。</p><h1 id="JDK环境配置"><a href="#JDK环境配置" class="headerlink" title="JDK环境配置"></a>JDK环境配置</h1><p>下面的软件很多会依赖Java环境，所以需要优先安装JDK。</p><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>项目目前使用jdk1.8 64位，本地开发环境可根据自身的硬件和操作系统配置选取。</p><p><a href="https://www.oracle.com/technetwork/cn/java/javase/downloads/jdk8-downloads-2133151-zhs.html" target="_blank" rel="noopener">jdk下载地址</a></p><p><strong>注意：jdk区分32位和64位</strong></p><h2 id="配置java环境变量"><a href="#配置java环境变量" class="headerlink" title="配置java环境变量"></a>配置java环境变量</h2><p>以windows 7为例，配置java环境变量:</p><ol><li>右键计算机，依次点击：<code>属性</code>|<code>高级系统设置</code>|<code>高级</code>|<code>环境变量</code>，在弹出的对话框中，找到系统变量，然后新建变量<code>JAVA_HOME</code>，配置该值为jdk安装目录。</li><li>在Path变量末尾追加<code>JAVA_HOME</code>的bin目录。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%JAVA_HOME%\bin;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：每个path需要以英文半角符 <code>;</code> 进行分割。</strong></p></blockquote><h1 id="构建工具配置"><a href="#构建工具配置" class="headerlink" title="构建工具配置"></a>构建工具配置</h1><h2 id="maven下载安装"><a href="#maven下载安装" class="headerlink" title="maven下载安装"></a>maven下载安装</h2><p>项目目前使用<em>maven</em>作为项目构建工具。</p><p><a href="http://mirrors.cnnic.cn/apache//maven/maven-3/3.2.5/binaries/" target="_blank" rel="noopener">maven下载地址</a> </p><p>版本：3.2.5</p><p>根据自己的配置下载对应的安装包，将安装包解压到指定目录之后还需要配置环境变量。</p><h2 id="maven环境变量配置"><a href="#maven环境变量配置" class="headerlink" title="maven环境变量配置"></a>maven环境变量配置</h2><p>以windows 7为例，配置maven环境变量:<br>1.右键计算机，依次点击：<code>属性</code>|<code>高级系统设置</code>|<code>高级</code>|<code>环境变量</code>，在弹出的对话框中，找到系统变量，然后新建变量：<code>M2_HOME</code>，配置该值为maven解压的目录。<br>2.在Path变量末尾追加maven执行目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%M2_HOME%\bin;</span><br></pre></td></tr></table></figure><h2 id="修改jar包仓库配置"><a href="#修改jar包仓库配置" class="headerlink" title="修改jar包仓库配置"></a>修改jar包仓库配置</h2><p>进入maven解压目录，找到conf目录并进入，打开并修改settings.xml，仓库的默认位置在C盘，按照个人需求修改本地仓库位置，建议修改为其他目录，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:\Java\m2\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时建议修改仓库镜像为阿里云镜像，避免jar包下载时间过长，可在mirrors的子节点添加以下信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="maven打包命令"><a href="#maven打包命令" class="headerlink" title="maven打包命令"></a>maven打包命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完整执行该命令既可</span></span><br><span class="line">mvn clean package install -U -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 以下为参数详解</span></span><br><span class="line"><span class="comment"># 清除</span></span><br><span class="line">mvn clean</span><br><span class="line"><span class="comment"># 打包</span></span><br><span class="line">mvn package</span><br><span class="line"><span class="comment"># 强制检查更新</span></span><br><span class="line">install -U</span><br><span class="line"><span class="comment"># 跳过测试用例</span></span><br><span class="line">-Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h1><ol><li>项目使用git进行版本控制 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载地址</a>，该工具本身提供命令行和图形化界面。</li><li>可视化git工具:SourceTree（可选，主要是降低使用难度）<a href="https://www.sourcetreeapp.com/download/" target="_blank" rel="noopener">下载地址</a>。</li></ol><h2 id="获取项目源代码"><a href="#获取项目源代码" class="headerlink" title="获取项目源代码"></a>获取项目源代码</h2><ol><li>第三方工具项目远程代码仓库克隆路径：<a href="https://code.aliyun.com/hlmy/hlmy-third-party.git" target="_blank" rel="noopener">https://code.aliyun.com/hlmy/hlmy-third-party.git</a></li><li>使用git clone $url 命令克隆项目到本地，并在项目路径下执行mave打包命令，将项目发布到本地仓库中。 </li><li>主项目远程代码仓库克隆路径：<a href="https://code.aliyun.com/hlmy/wx1758.git" target="_blank" rel="noopener">https://code.aliyun.com/hlmy/wx1758.git</a></li><li>克隆主项目到本地。</li><li>主项目本身依赖了部分第三方工具jar包，需要执行项目<code>doc/schema</code>中的<code>maven_install.sh</code>脚本，将第三方jar包发布到本地仓库中。</li></ol><h1 id="WEB容器配置"><a href="#WEB容器配置" class="headerlink" title="WEB容器配置"></a>WEB容器配置</h1><p>项目使用web容器为：tomcat</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.28/bin/" target="_blank" rel="noopener">tomcat下载地址</a> </p><p>版本：8.5</p><p><strong>注意：tomcat区分32位和64位</strong></p><h1 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h1><p>项目使用mysql作为数据存储（目前直接使用测试数据库，可不安装）。</p><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">下载地址</a> </p><p>Version:5.6</p><h2 id="配置mysql环境变量"><a href="#配置mysql环境变量" class="headerlink" title="配置mysql环境变量"></a>配置mysql环境变量</h2><p>以windows7为例，右键计算机，依次点击：<code>属性</code>|<code>高级系统设置</code>|<code>高级</code>|<code>环境变量</code>，在弹出的对话框中，找到系统变量，然后选择<code>PATH</code>,在其后面添加(注意是追加,不是覆盖): 你的mysql bin文件夹的路径 (如:C:\Program Files\MySQL\MySQL Server 5.6\bin)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=.......;C:\Program Files\MySQL\MySQL Server 5.6\bin</span><br></pre></td></tr></table></figure><p>mysql-5.6.X默认的配置文件是在C:\Program Files\MySQL\MySQL Server 5.6\my-default.ini，或者自己建立一个my.ini文件，<br>在其中修改或添加配置： </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">basedir</span>=C:\Program Files\MySQL\MySQL Server <span class="number">5.6</span>（mysql所在目录） </span><br><span class="line"><span class="attr">datadir</span>=C:\Program Files\MySQL\MySQL Server <span class="number">5.6</span>\data （mysql所在目录\data）</span><br><span class="line"><span class="comment"># 以下配置为方便导入mysql大数据的配置</span></span><br><span class="line"><span class="attr">join_buffer_size</span> = <span class="number">128</span>M</span><br><span class="line"><span class="attr">sort_buffer_size</span> = <span class="number">16</span>M</span><br><span class="line"><span class="attr">read_rnd_buffer_size</span> = <span class="number">32</span>M</span><br></pre></td></tr></table></figure><h2 id="启动mysql服务"><a href="#启动mysql服务" class="headerlink" title="启动mysql服务"></a>启动mysql服务</h2><p>以管理员身份运行cmd,执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Program Files\MySQL\MySQL Server 5.6\bin </span><br><span class="line">mysqld -install</span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure><blockquote><ol><li><strong>必须进入mysql的bin文件夹，不管有没有配置过环境变量，也要进入bin文件夹，否则之后启动服务仍然会报错误</strong></li><li><strong>如果不用管理员身份运行，将会因为权限不够而出现错误：Install/Remove of the Service Denied!</strong></li></ol></blockquote><h2 id="安装数据库设计工具"><a href="#安装数据库设计工具" class="headerlink" title="安装数据库设计工具"></a>安装数据库设计工具</h2><p>navicat:  数据库设计工具<a href="http://www.navicat.com.cn/download/navicat-premium" target="_blank" rel="noopener">下载地址</a></p><p>配置好本地库连接之后，导入项目中doc目录下的的数据库脚本game_store.sql文件。（可选）</p><h1 id="IDE配置"><a href="#IDE配置" class="headerlink" title="IDE配置"></a>IDE配置</h1><h2 id="IDE下载"><a href="#IDE下载" class="headerlink" title="IDE下载"></a>IDE下载</h2><p>根据个人喜好，使用对应的ide，项目推介使用IDE为：</p><ol><li>sts(spring toolit suite，一个集成spring开发插件并优化开发流程的eclipse版本) <a href="http://spring.io/tools/sts/legacy" target="_blank" rel="noopener">下载地址</a> </li><li>IntelliJ IDEA<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">下载地址</a> </li></ol><p><strong>注意：IDE区分32位和64位</strong></p><h2 id="IDE配置-1"><a href="#IDE配置-1" class="headerlink" title="IDE配置"></a>IDE配置</h2><blockquote><p>导入项目之前，需要先修改maven配置文件。</p></blockquote><p>sts配置：点击<code>windows</code>|<code>preferences</code>|<code>maven</code>|<code>usersettings</code>,修改GlobalSettings为maven settings.xml文件所在目录，点击更新，看到Local Repository更新为自定义目录即可。</p><h1 id="远程连接工具"><a href="#远程连接工具" class="headerlink" title="远程连接工具"></a>远程连接工具</h1><p>mobaxterm <a href="https://mobaxterm.mobatek.net/" target="_blank" rel="noopener">下载地址</a> </p><h1 id="ftp传输工具"><a href="#ftp传输工具" class="headerlink" title="ftp传输工具"></a>ftp传输工具</h1><p>FileZilla <a href="https://filezilla-project.org/" target="_blank" rel="noopener">下载地址</a> </p><h1 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h1><p>下载<br>linux <a href="http://memcached.org/downloads" target="_blank" rel="noopener">下载地址</a><br>windows <a href="http://static.runoob.com/download/memcached-1.4.5-amd64.zip" target="_blank" rel="noopener">下载地址</a></p><h2 id="windows服务方式安装"><a href="#windows服务方式安装" class="headerlink" title="windows服务方式安装"></a>windows服务方式安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载服务：</span></span><br><span class="line">schtasks /delete /tn memcached</span><br><span class="line">d:\develop\memcached\memcached.exe -d uninstall</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启服务：</span></span><br><span class="line">d:\develop\memcached\memcached.exe -d install</span><br><span class="line">schtasks /create /sc onstart /tn memcached /tr <span class="string">"'d:\develop\memcached\memcached.exe' -m 512"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动停止</span></span><br><span class="line">d:\develop\memcached\memcached.exe -d start</span><br><span class="line">d:\develop\memcached\memcached.exe -d stop</span><br><span class="line"><span class="string">"d:\develop\memcached\memcached.exe"</span> -d runservice -m 512</span><br></pre></td></tr></table></figure><h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><p><a href="https://www.apache.org/dyn/closer.cgi/zookeeper/" target="_blank" rel="noopener">下载地址</a> </p><h2 id="Windows服务方式安装"><a href="#Windows服务方式安装" class="headerlink" title="Windows服务方式安装"></a>Windows服务方式安装</h2><ol><li>下载的Zookeeper是 *.cmd 的批处理命令运行的，默认没有提供以windows服务的方式运行的方案。</li><li>以服务方式下载prunsrv（第三方开源工具，可以以服务方式启动软件） <a href="http://archive.apache.org/dist/commons/daemon/binaries/windows/" target="_blank" rel="noopener">下载地址</a></li><li>解压后复制文件，<code>64位机器用amd64/prunsrv.exe</code><ol><li>复制 commons-daemon-1.0.15-bin-windows/amd64/prunsrv.exe 至 zookeeper-3.4.8\bin目录下，这是做服务的执行程序 </li><li>复制 commons-daemon-1.0.15-bin-windows/prunmgr.exe 至 zookeeper-3.4.8\bin目录下，监控服务配置及运行的程序 </li></ol></li><li>配置环境变量，添加<code>ZOOKEEPER_SERVICE</code>， <code>ZOOKEEPER_HOME</code>两个环境变量：<ol><li>ZOOKEEPER_SERVICE：服务名称（不要有中文）</li><li>ZOOKEEPER_HOME：设置到zookeeper-3.4.8目录下</li></ol></li><li>生成zoo.cfg，在zookeeper-3.4.8\conf目录下复制一份zoo_sample.cfg文件，并重命名为zoo.cfg</li><li><p>在zookeeper-3.4.8\bin目录下添加一个 zkServerStop.cmd 文件<br>内容如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">setlocal</span></span><br><span class="line">TASKLIST /svc | <span class="built_in">findstr</span> /c:"<span class="variable">%ZOOKEEPER_SERVICE%</span>" &gt; <span class="variable">%ZOOKEEPER_HOME%</span>\zookeeper_svc.pid</span><br><span class="line"><span class="keyword">FOR</span> /F "tokens=<span class="number">2</span> delims= " <span class="variable">%%G</span> <span class="keyword">IN</span> (<span class="variable">%ZOOKEEPER_HOME%</span>\zookeeper_svc.pid) <span class="keyword">DO</span> (</span><br><span class="line">    @<span class="built_in">set</span> zkPID=<span class="variable">%%G</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">taskkill</span> /PID <span class="variable">%zkPID%</span> /T /F</span><br><span class="line"><span class="built_in">del</span> <span class="variable">%ZOOKEEPER_HOME%</span>/zookeeper_svc.pid</span><br><span class="line"><span class="built_in">endlocal</span></span><br></pre></td></tr></table></figure></li><li><p>新建一个批处理安装文件：install.bat　　<br>内容如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prunsrv.exe "//IS//<span class="variable">%ZOOKEEPER_SERVICE%</span>" --DisplayName="Zookeeper (<span class="variable">%ZOOKEEPER_SERVICE%</span>)" --Description="Zookeeper (<span class="variable">%ZOOKEEPER_SERVICE%</span>)" --Startup=auto --StartMode=exe --StartPath=<span class="variable">%ZOOKEEPER_HOME%</span> --StartImage=<span class="variable">%ZOOKEEPER_HOME%</span>\bin\zkServer.<span class="built_in">cmd</span> --StopPath=<span class="variable">%ZOOKEEPER_HOME%</span>\ --StopImage=<span class="variable">%ZOOKEEPER_HOME%</span>\bin\zkServerStop.<span class="built_in">cmd</span> --StopMode=exe --StopTimeout=<span class="number">5</span> --LogPath=<span class="variable">%ZOOKEEPER_HOME%</span>\logs --LogPrefix=zookeeper-wrapper --PidFile=zookeeper.pid --LogLevel=Info --StdOutput=auto --StdError=auto</span><br></pre></td></tr></table></figure></li><li><p>在cmd中以管理员身份运行install.bat文件。</p></li></ol><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><p>（可选），目前基于测试环境的redis，本地无需搭建。 <a href="https://redis.io/download" target="_blank" rel="noopener">下载地址</a> </p><h1 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h1><table><thead><tr><th>工具名称</th><th>工具描述</th><th>下载地址</th></tr></thead><tbody><tr><td>mybatis generator插件</td><td>可以自动生成代码，创建DAO层相关代码。（可选）</td><td></td></tr><tr><td>Beyond Compare</td><td>文件对比工具</td><td></td></tr><tr><td>jd-gui</td><td>java反编译工具</td><td><a href="http://jd.benow.ca/" target="_blank" rel="noopener">下载地址</a></td></tr><tr><td>VSCode</td><td>文本编辑器</td><td><a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">下载地址</a></td></tr><tr><td>oss-browser</td><td>oss文件管理</td><td><a href="https://help.aliyun.com/document_detail/61872.html" target="_blank" rel="noopener">下载地址</a></td></tr><tr><td>redisdesktop</td><td>redis桌面管理器</td><td></td></tr><tr><td>Charles</td><td>网络抓包工具</td><td></td></tr></tbody></table><ol><li>下载MyBatis_Generator_1.3.1.zip文件并解压，将解压得到的2个文件夹<code>features</code>和<code>plugins</code> copy到 eclipse的安装目录下，重启即可 。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现整理了项目开发所需的环境搭建教程，可参考下文配置开发环境，示例为windows环境下的教程，其他环境请自行调整。&lt;/p&gt;
&lt;h1 id=&quot;JDK环境配置&quot;&gt;&lt;a href=&quot;#JDK环境配置&quot; class=&quot;headerlink&quot; title=&quot;JDK环境配置&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="后端" scheme="http://fatesx.gitee.io/blog/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="1758" scheme="http://fatesx.gitee.io/blog/tags/1758/"/>
    
      <category term="开发环境" scheme="http://fatesx.gitee.io/blog/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>Sql优化</title>
    <link href="http://fatesx.gitee.io/blog/2018/03/31/101-sql%E4%BC%98%E5%8C%96/"/>
    <id>http://fatesx.gitee.io/blog/2018/03/31/101-sql优化/</id>
    <published>2018-03-31T05:23:50.000Z</published>
    <updated>2018-04-09T11:08:42.289Z</updated>
    
    <content type="html"><![CDATA[<p>Sql优化</p><p>核心：</p><pre><code> sql优化的第一核心思想就是避免全表扫描   竟量使用索引查询，但是建立索引时，要注意，在inster，update，语句执行时，会重建索引。所以一切都要适中就可以了（数据库的读写分离可以避免这个问题）==  sql语句优化的第二，就应该从占用空间去考虑，占用空间越小，就效率高。 sql优化，第三，应该从设计表的结构考虑，能设计为数字的，就设置为num，不要使用char，因为比较的时候也是按照字符比，所以数字只比较一次，效率会快。                 注意;我们学过的自关联设计（减少表，也要缩减表） sql优化，第四，从事物角度，竟量使用小事物隔离级别（数据允许有错时），大事物，会影响并发。 sql优化，第五，从游标，存储过程，储存函数，的角度去回答。</code></pre><p>具体措施：<br>1，使用索引查询，可以提高效率<br>2，使用vachar代替char，可以节省存储空间。<br>3，使用字段代理*查询，避免查询任何不需要的字段<br>4，使用复合索引查询时，只有使用第一个字段查询时，才会使用索引查询。<br>5，竟量避免使用临时表。如果使用到了，使用后要显示的删除，避免临时表的长期锁定。（但是如果表太大时，我们经常使用其中的几个数据，就可以考虑使用临时表，但是这是我们就应该考虑分离表了）<br>6，能定义为num的字段就定义为num。<br>7，合理使用游标（存储的结果集），会提高性能。</p><p>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 </p><p>2.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 </p><p>3.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>可以这样查询： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> </span><br><span class="line"><span class="keyword">union</span> all </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>5.模糊查询也将导致全表扫描：<br>select id from t where name like ‘%abc%’<br>若要提高效率，可以考虑全文检索。 </p><p>6.in 和 not in 也要慎用，否则会导致全表扫描，如：<br>select id from t where num in(1,2,3)<br>对于连续的数值，能用 between 就不要用 in 了：<br>select id from t where num between 1 and 3 </p><ol start="7"><li>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<br>select id from t where num=@num<br>可以改为强制查询使用索引：<br>select id from t with(index(索引名)) where num=@num </li></ol><p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>select id from t where num/2=100<br>应改为:<br>select id from t where num=100*2 </p><p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>select id from t where substring(name,1,3)=’abc’–name以abc开头的id<br>select id from t where datediff(day,createdate,’2005-11-30’)=0–’2005-11-30’生成的id<br>应改为:<br>select id from t where name like ‘abc%’<br>select id from t where createdate&gt;=’2005-11-30’ and createdate&lt;’2005-12-1’ </p><p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。<br>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 </p><p>12.不要写一些没有意义的查询，如需要生成一个空表结构：<br>select col1,col2 into #t from t where 1=0<br>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br>create table #t(…) </p><p>13.很多时候用 exists 代替 in 是一个好的选择：<br>select num from a where num in(select num from b)<br>用下面的语句替换：<br>select num from a where exists(select 1 from b where num=a.num) </p><p>14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 </p><ol start="15"><li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。 </li></ol><p>16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 </p><p>17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 </p><p>18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 </p><p>19.任何地方都不要使用 select<em>from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段。 </p><p>20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。<br>21.避免频繁创建和删除临时表，以减少系统表资源的消耗。 </p><p>22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 </p><p>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 </p><p>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 </p><p>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 </p><p>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 </p><ol start="27"><li>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 </li></ol><p>28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 </p><p>29.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 </p><p>30.尽量避免大事务操作，提高系统并发能力。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Sql优化&lt;/p&gt;
&lt;p&gt;核心：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; sql优化的第一核心思想就是避免全表扫描   
竟量使用索引查询，但是建立索引时，要注意，在inster，update，语句执行时，会重建索引。所以一切都要适中就可以了（数据库的读写分离可以避免这个问题）==
      
    
    </summary>
    
    
      <category term="sql" scheme="http://fatesx.gitee.io/blog/categories/sql/"/>
    
    
      <category term="1758" scheme="http://fatesx.gitee.io/blog/tags/1758/"/>
    
      <category term="sql" scheme="http://fatesx.gitee.io/blog/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>JSP 标准标签库（JSP Standard Tag Library）</title>
    <link href="http://fatesx.gitee.io/blog/2018/03/31/090-JSP%20%E6%A0%87%E5%87%86%E6%A0%87%E7%AD%BE%E5%BA%93/"/>
    <id>http://fatesx.gitee.io/blog/2018/03/31/090-JSP 标准标签库/</id>
    <published>2018-03-31T05:23:50.000Z</published>
    <updated>2018-04-09T11:08:30.455Z</updated>
    
    <content type="html"><![CDATA[<p>JSTL是一个 JSP 标签集合，它封装了 JSP 应用的通用核心功能。 它的出现，是因为人们开始注重软件的分层设计，不希望在 JSP 页面中出现 JAVA 逻辑代码。同时也由于自定义标签的开发难度较大、不利于技术的标准化，因此产生了JSTL。<strong>JSTL和EL</strong> 的结合，基本可以让页面再无 &lt;% %&gt; 代码。<br>JSTL 标准标签库可分为五类：<strong>[其实,一般就用三种]</strong> </p><h2 id="核心标签库"><a href="#核心标签库" class="headerlink" title="核心标签库"></a>核心标签库</h2><p>共 14 个，从功能上可以分为 4 类。<br>引用方法： 引入方式: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jstl/core_rt"</span> %&gt;</span><br></pre></td></tr></table></figure><h3 id="表达式控制"><a href="#表达式控制" class="headerlink" title="表达式控制"></a>表达式控制</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;c:out&gt;</td><td>用于显示数据，就像 &lt;%= %&gt; ，区别在于 &lt;c:out&gt; 标签可以直接通过 . 操作符来访问属性</td></tr><tr><td>&lt;c:set &gt;</td><td>用于保存数据</td></tr><tr><td>&lt;c:remove&gt;</td><td>用于删除数据</td></tr><tr><td>&lt;c:catch &gt;</td><td>用来处理产生错误的异常状况，并且将错误信息储存起来</td></tr></tbody></table><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;c:if &gt;</td><td>与我们在一般程序中用的 if 一样,但是没有else操作,变相实现</td></tr><tr><td>&lt;c:choose &gt;</td><td>本身只当做 &lt;c:when&gt; 和 &lt;c:otherwise&gt; 的父标签,相当于 switch 标签</td></tr><tr><td>&lt;c:when&gt;</td><td>&lt;c:choose&gt; 的子标签，用来判断条件是否成立</td></tr><tr><td>&lt;c:otherwise&gt;</td><td>&lt;c:choose&gt; 的子标签，接在 &lt;c:when&gt; 标签后，当 &lt;c:when&gt; 标签判断为 false 时被执行</td></tr></tbody></table><h3 id="循环-重点"><a href="#循环-重点" class="headerlink" title="循环[重点]"></a>循环[重点]</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;c:forEach&gt;</td><td>基础迭代标签，接受多种集合类型</td></tr><tr><td>&lt;c:forTokens&gt;</td><td>根据指定的分隔符来分隔内容并迭代输出</td></tr></tbody></table><h3 id="URL操作"><a href="#URL操作" class="headerlink" title="URL操作"></a>URL操作</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;c:import&gt;</td><td>检索一个绝对或相对 URL，然后将其内容暴露给页面,可以替换JSP的动态包含</td></tr><tr><td>&lt;c:redirect&gt;</td><td>使用可选的查询参数来创造一个 URL</td></tr><tr><td>&lt;c:url &gt;</td><td>重定向至一个新的 URL</td></tr><tr><td>&lt;c:param &gt;</td><td>用来给包含或重定向的页面传递参数</td></tr></tbody></table><h2 id="格式化标签库"><a href="#格式化标签库" class="headerlink" title="格式化标签库"></a>格式化标签库</h2><p>用于格式化并输出文本、日期、时间、数字，这里只介绍最最最常用的两个标签,引用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@taglib prefix=<span class="string">"fmt"</span> uri=<span class="string">"http://java.sun.com/jstl/fmt_rt"</span> %&gt;</span><br></pre></td></tr></table></figure><h3 id="格式化数字"><a href="#格式化数字" class="headerlink" title="格式化数字"></a>格式化数字</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;fmt:formatNumber&gt;</td><td>使用指定的格式或精度格式化数字,</td></tr></tbody></table><p><strong>涉及到钱的时候,不要使用float/double,还有使用银行家四舍五入方式</strong></p><h3 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;fmt:formatDate&gt;</td><td>使用指定的风格或模式格式化日期和时间</td></tr></tbody></table><p><strong>yyyy mm MM dd H h ss</strong> </p><h2 id="函数标签库"><a href="#函数标签库" class="headerlink" title="函数标签库"></a>函数标签库</h2><p>大部分都是通用的字符串处理函数，用于配合 EL 表达式使用。引用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@taglib prefix=<span class="string">"fn"</span> uri=<span class="string">"http://java.sun.com/jstl/functions_rt"</span> %&gt;</span><br></pre></td></tr></table></figure><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>fn:contains()</td><td>测试输入的字符串是否包含指定的子串,如: ${fn:contains(“ABC”, “a”)}</td></tr><tr><td>fn:containsIgnoreCase()</td><td>测试输入的字符串是否包含指定的子串，大小写不敏感,如: ${fn:containsIgnoreCase(“ABC”, “a”)}</td></tr><tr><td>fn:endsWith()</td><td>测试输入的字符串是否以指定的后缀结尾,如:${fn:endsWith(“ABC”, “bc”)}</td></tr><tr><td>fn:startsWith()</td><td>测试输入的字符串是否以指定的前缀开始,如:${fn:startsWith(“ABC”, “ab”)}</td></tr><tr><td>fn:escapeXml()</td><td>用于将所有特殊字符转化为字符实体码。它只包含一个 string 参数，返回一个 String 类型的值</td></tr><tr><td>fn:indexOf()</td><td>用于取得子字符串与源字符串匹配的开始位置，若子字符串与源字符串中的内容没有匹配成功将返回“ -1 ”。它包括 string 和 substring 两个参数，返回结果为 int 类型.如:${fn:indexOf(“ABCD”,”aBC”)}</td></tr><tr><td>fn:join()</td><td>将数组中的元素合成一个字符串然后输出</td></tr><tr><td>fn:length()</td><td>返回字符串长度</td></tr><tr><td>fn:replace()</td><td>将输入字符串中指定的位置替换为指定的字符串然后返回</td></tr><tr><td>fn:split()</td><td>将字符串用指定的分隔符分隔然后组成一个子字符串数组并返回</td></tr><tr><td>fn:substring()</td><td>返回字符串的子集,如:${fn:substring(“ABC”,”1”,”2”)}</td></tr><tr><td>fn:substringAfter()</td><td>返回字符串在指定子串之后的子集,如:${fn:substringAfter(“ABCD”,”BC”)}</td></tr><tr><td>fn:substringBefore()</td><td>返回字符串在指定子串之前的子集,如:${fn:substringBefore(“ABC”,”1”,”2”)}</td></tr><tr><td>fn:toLowerCase()</td><td>将字符串中的字符转为小写</td></tr><tr><td>fn:toUpperCase()</td><td>将字符串中的字符转为大写</td></tr><tr><td>fn:trim()</td><td>移除首位的空白符</td></tr></tbody></table><h2 id="SQL标库"><a href="#SQL标库" class="headerlink" title="SQL标库"></a>SQL标库</h2><p>（之后补充）</p><h2 id="XML标签库"><a href="#XML标签库" class="headerlink" title="XML标签库"></a>XML标签库</h2><p>（之后补充）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSTL是一个 JSP 标签集合，它封装了 JSP 应用的通用核心功能。 它的出现，是因为人们开始注重软件的分层设计，不希望在 JSP 页面中出现 JAVA 逻辑代码。同时也由于自定义标签的开发难度较大、不利于技术的标准化，因此产生了JSTL。&lt;strong&gt;JSTL和EL
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JSP" scheme="http://fatesx.gitee.io/blog/categories/java%E5%9F%BA%E7%A1%80/JSP/"/>
    
    
      <category term="1758" scheme="http://fatesx.gitee.io/blog/tags/1758/"/>
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>集群tomcat环境下的Session共享</title>
    <link href="http://fatesx.gitee.io/blog/2018/03/20/020-SessionMemcache/"/>
    <id>http://fatesx.gitee.io/blog/2018/03/20/020-SessionMemcache/</id>
    <published>2018-03-20T05:23:50.000Z</published>
    <updated>2018-04-09T11:08:18.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：李乾</p></blockquote><h2 id="使用Memcache共享集群中的SESSION"><a href="#使用Memcache共享集群中的SESSION" class="headerlink" title="使用Memcache共享集群中的SESSION"></a>使用Memcache共享集群中的SESSION</h2><p>在Web服务开发中，时常会使用到SESSION，默认情况下会使用Web容器自身的SessionManager来管理session，但在集群环境下，会面临SESSION共享的问题。</p><p>以tomcat为例，可以自己写tomcat的扩展来保存SESSION到memcached。</p><p>这里推荐使用memcached-session-manager这个开源项目（<a href="http://code.google.com/p/memcached-session-manager/" target="_blank" rel="noopener">http://code.google.com/p/memcached-session-manager/</a> ），下面简称msm。</p><p>下面分步实现基于tomcat集群配置：</p><blockquote><p>此配置已经过验证，并在1758的多个Web服务中使用，如：支付服务，H5服务，MiniWeb服务。</p></blockquote><p>1758线上环境（jdk1.6， tomcat7.0） </p><h2 id="1、根据环境下载相应依赖包（针对jdk1-6版本）"><a href="#1、根据环境下载相应依赖包（针对jdk1-6版本）" class="headerlink" title="1、根据环境下载相应依赖包（针对jdk1.6版本）"></a>1、根据环境下载相应依赖包（针对jdk1.6版本）</h2><p>memcached-session-manager-1.6.0.jar<br>memcached-session-manager-tc7-1.6.0.jar<br>msm-javolution-serializer-1.6.0.jar<br>javolution-5.4.3.1.jar<br>spymemcached-2.7.3.jar</p><p>如果是jdk1.7，需要下载相对应的jar包。</p><h2 id="2、部署依赖包"><a href="#2、部署依赖包" class="headerlink" title="2、部署依赖包"></a>2、部署依赖包</h2><p>将这5个包放到$TOMCAT_HOME/lib目录下</p><h2 id="3、修改配置"><a href="#3、修改配置" class="headerlink" title="3、修改配置"></a>3、修改配置</h2><p>修改$TOMCAT_HOME/conf/context.xml，在context节点下增加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;</span><br><span class="line">memcachedNodes=&quot;localhost:11211&quot;</span><br><span class="line">sticky=&quot;false&quot;</span><br><span class="line">memcachedProtocol=&quot;binary&quot;</span><br><span class="line">sessionBackupAsync=&quot;false&quot;</span><br><span class="line">requestUriIgnorePattern=&quot;.*\.(png|gif|jpg|css|js)$&quot;</span><br><span class="line">transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.javolution.JavolutionTranscoderFactory&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>这里的memcachedNodes是填写memcached节点,多个节点时可以以空隔分开，如:<br>n1:localhost:11211 n2:localhost:11212</p><h2 id="4、验证"><a href="#4、验证" class="headerlink" title="4、验证"></a>4、验证</h2><p>同样的配置启动两个TOMCAT,即可解决SESSION的共享问题.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：李乾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用Memcache共享集群中的SESSION&quot;&gt;&lt;a href=&quot;#使用Memcache共享集群中的SESSION&quot; class=&quot;headerlink&quot; title=&quot;使用Memc
      
    
    </summary>
    
    
      <category term="java web" scheme="http://fatesx.gitee.io/blog/categories/java-web/"/>
    
    
      <category term="1758" scheme="http://fatesx.gitee.io/blog/tags/1758/"/>
    
      <category term="java web" scheme="http://fatesx.gitee.io/blog/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>Spring工具类ToStringBuilder用法简介</title>
    <link href="http://fatesx.gitee.io/blog/2018/03/12/012-%E5%B7%A5%E5%85%B7%E7%B1%BBToStringBuilder%E7%AE%80%E4%BB%8B/"/>
    <id>http://fatesx.gitee.io/blog/2018/03/12/012-工具类ToStringBuilder简介/</id>
    <published>2018-03-12T05:23:50.000Z</published>
    <updated>2018-04-09T11:08:09.121Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>author:xuejw&gt; </p></blockquote><p>系统中一般都要打印日志的，因为所有实体的toString()方法,不是输出对象的hashcode值，就是用的是简单的”+”连接拼接输出每个属性值，但是每”＋”一个就会 new一个String对象，这样如果系统内存小的话会暴内存（前提系统实体比较多）。使用ToStringBuilder就可以避免暴内存这种问题的，特别是在参数为对象时，该工具类能够很方便的自动打印对象中的属性值。</p><h2 id="添加依赖jar包"><a href="#添加依赖jar包" class="headerlink" title="添加依赖jar包"></a>添加依赖jar包</h2><p>首先，使用maven添加依赖jar包commons-lang，在pom.xml中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-lang&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="ToStringBuilder的append方法"><a href="#ToStringBuilder的append方法" class="headerlink" title="ToStringBuilder的append方法"></a>ToStringBuilder的append方法</h2><p>ToStringBuilder中append方法可以向该类添加基本类型、数组、和对象，只有添加的属性值才会被toString输出。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal income;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthDate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthDate</span><span class="params">(Date birthDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getIncome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIncome</span><span class="params">(BigDecimal income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.income = income;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age, Date birthDate, BigDecimal income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birthDate = birthDate;</span><br><span class="line">        <span class="keyword">this</span>.income = income;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ToStringBuilder(<span class="keyword">this</span>).append(<span class="string">"name"</span>, name).append(<span class="string">"age"</span>, age).append(<span class="string">"birthDate"</span>, birthDate)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ToStringBuilder的append方法  </span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"张三"</span>, <span class="number">25</span>, <span class="keyword">new</span> Date(), <span class="keyword">new</span> BigDecimal(<span class="string">"5000"</span>));</span><br><span class="line">System.out.println(<span class="string">"ToStringBuilder的append方法: "</span> + user.toString());</span><br></pre></td></tr></table></figure><p>运行结果如下：   </p><p>ToStringBuilder的append方法: com.bruc.myproject.User@1cd5f53f[name=张三,age=25,birthDate=Mon Aug 15 10:03:07 CST 2016]</p><h2 id="ToStringBuilder的reflectionToString方法"><a href="#ToStringBuilder的reflectionToString方法" class="headerlink" title="ToStringBuilder的reflectionToString方法"></a>ToStringBuilder的reflectionToString方法</h2><p>该方法主要是把类对应的基本属性和值输出来，比如说我们需要打印类的所有User参数对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflectionToString方法</span></span><br><span class="line"><span class="comment">// 对象及其属性一行显示</span></span><br><span class="line">System.out.println(ToStringBuilder.reflectionToString(user));</span><br><span class="line">System.out.println(ToStringBuilder.reflectionToString(user, ToStringStyle.DEFAULT_STYLE));</span><br><span class="line"><span class="comment">// 属性换行显示</span></span><br><span class="line">System.out.println(ToStringBuilder.reflectionToString(user, ToStringStyle.MULTI_LINE_STYLE));</span><br><span class="line"><span class="comment">// 不显示属性名，只显示属性值，在同一行显示</span></span><br><span class="line">System.out.println(ToStringBuilder.reflectionToString(user, ToStringStyle.NO_FIELD_NAMES_STYLE));</span><br><span class="line"><span class="comment">// 对象名称简写</span></span><br><span class="line">System.out.println(ToStringBuilder.reflectionToString(user, ToStringStyle.SHORT_PREFIX_STYLE));</span><br><span class="line"><span class="comment">// 只显示属性</span></span><br><span class="line">System.out.println(ToStringBuilder.reflectionToString(user, ToStringStyle.SIMPLE_STYLE));</span><br></pre></td></tr></table></figure></p><p>对应输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象及其属性一行显示</span></span><br><span class="line">com.bruc.myproject.User@<span class="number">1</span>cd5f53f[name=张三,age=<span class="number">25</span>,birthDate=Mon Aug <span class="number">15</span> <span class="number">10</span>:<span class="number">03</span>:<span class="number">07</span> CST <span class="number">2016</span>,income=<span class="number">5000</span>]</span><br><span class="line">com.bruc.myproject.User@<span class="number">1</span>cd5f53f[name=张三,age=<span class="number">25</span>,birthDate=Mon Aug <span class="number">15</span> <span class="number">10</span>:<span class="number">03</span>:<span class="number">07</span> CST <span class="number">2016</span>,income=<span class="number">5000</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性换行显示</span></span><br><span class="line">com.bruc.myproject.User@<span class="number">1</span>cd5f53f[</span><br><span class="line">  name=张三</span><br><span class="line">  age=<span class="number">25</span></span><br><span class="line">  birthDate=Mon Aug <span class="number">15</span> <span class="number">10</span>:<span class="number">03</span>:<span class="number">07</span> CST <span class="number">2016</span></span><br><span class="line">  income=<span class="number">5000</span></span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不显示属性名，只显示属性值，在同一行显示</span></span><br><span class="line">com.bruc.myproject.User@<span class="number">1</span>cd5f53f[张三,<span class="number">25</span>,Mon Aug <span class="number">15</span> <span class="number">10</span>:<span class="number">03</span>:<span class="number">07</span> CST <span class="number">2016</span>,<span class="number">5000</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象名称简写</span></span><br><span class="line">User[name=张三,age=<span class="number">25</span>,birthDate=Mon Aug <span class="number">15</span> <span class="number">10</span>:<span class="number">03</span>:<span class="number">07</span> CST <span class="number">2016</span>,income=<span class="number">5000</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只显示属性</span></span><br><span class="line">张三,<span class="number">25</span>,Mon Aug <span class="number">15</span> <span class="number">10</span>:<span class="number">03</span>:<span class="number">07</span> CST <span class="number">2016</span>,<span class="number">5000</span></span><br></pre></td></tr></table></figure><blockquote><p>补充点：</p></blockquote><p>commons-lang中工具类比较多，这里简单介绍几个主要的：<br>ClassUtils：提供操作class类的方法。<br>NumberUtils： 关于数字以及数字和字符串转换的类。<br>RandomUtils： 用于产生随机数的。<br>DateFormatUtils： 日期时间格式转换，以及本地时间和 UTC 时间转换。<br>DateUtils： 日期工具类。</p><p>基于反射机制的几个类：<br>CompareToBuilder： 比较，用在算法、排序、比较的地方，reflectionCompare，append。<br>EqualsBuilder： 通过反射机制比较。<br>HashCodeBuilder： 可以通过反射生成 hash code。<br>ToStringBuilder： 当你需要重载 toString 函数而不想写代码把当前类的所有成员信息列出来，可以用这个函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;author:xuejw&amp;gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;系统中一般都要打印日志的，因为所有实体的toString()方法,不是输出对象的hashcode值，就是用的是简单的”+”连接拼接输出每个属性值，但是每”＋”一个就会 n
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="1758" scheme="http://fatesx.gitee.io/blog/tags/1758/"/>
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>excel导出</title>
    <link href="http://fatesx.gitee.io/blog/2018/03/11/011-ExcleExport/"/>
    <id>http://fatesx.gitee.io/blog/2018/03/11/011-ExcleExport/</id>
    <published>2018-03-11T05:23:50.000Z</published>
    <updated>2018-04-09T11:08:00.553Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>author:xuejw</p></blockquote><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>首先，使用maven添加依赖jar包poi，在pom.xml中添加</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.14&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="设计类："><a href="#设计类：" class="headerlink" title="设计类："></a>设计类：</h2><p><strong>ExportConvertRule<t></t></strong> ：Excel导出规则类<br><strong>WyExportExcelView<t></t></strong> ：web实现文件导出类，需继承AbstractExcelView。<br><strong>ExportExcel<t></t></strong>：导出Excle实现类，创建时指定具体javabean对象类型，生成Excle工作簿对象。</p><h2 id="WyExportExcelView"><a href="#WyExportExcelView" class="headerlink" title="WyExportExcelView"></a>WyExportExcelView</h2><p>从 Controller 传入的model中获取导出文件名、工作表名、 导出的列和数据，并调用ExportExcel的导出方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置response方式,使执行此controller时自动出现下载页面,而非直接使用excel打开</span></span><br><span class="line">response.setContentType(<span class="string">"application/vnd.ms-excel"</span>);</span><br></pre></td></tr></table></figure><p>将工作表名、规则列表LIst、输出流和数据项Collection传给ExportExcel，控制数据导出内容到输出流上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStream out = response.getOutputStream();  </span><br><span class="line">exportExcel.exportExcel(title, exportConvertRuleList, dataList, out);</span><br></pre></td></tr></table></figure><h2 id="ExportConvertRule"><a href="#ExportConvertRule" class="headerlink" title="ExportConvertRule"></a>ExportConvertRule</h2><p>设置Excel导出内容的规则类，指定导出列、标题、日期格式化规则和内容转换（根据实际需求添加） 。<br>使用<strong><em>设计模式之建造者模式(Builder)模式</em></strong>，因为列名和列属性是成对出现且必须的字段，而内容转换和日期规则则是可选的，因此Builder对象构造函数必须传入列属性和列名，规则和日期格式可用set方法补充设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Excel导出规则</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportConvertRule</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String columnTitle;<span class="comment">// 列标题</span></span><br><span class="line">    <span class="keyword">private</span> String columnName;<span class="comment">// 列属性值，对应实体属性名</span></span><br><span class="line">    <span class="keyword">private</span> SimpleDateFormat datePattern = <span class="keyword">null</span>;<span class="comment">// 日期输出格式</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;T, String&gt; converter = <span class="keyword">null</span>; <span class="comment">// 内容替换规则，例如 0:微支付 1:支付宝</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExportConvertRule</span><span class="params">(ExportConvertRuleBuilder&lt;T&gt; exportConvertRuleBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.columnTitle = exportConvertRuleBuilder.columnTitle;</span><br><span class="line">        <span class="keyword">this</span>.columnName = exportConvertRuleBuilder.columnName;</span><br><span class="line">        <span class="keyword">this</span>.datePattern = exportConvertRuleBuilder.datePattern;</span><br><span class="line">        <span class="keyword">this</span>.converter = exportConvertRuleBuilder.converter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColumnTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> columnTitle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColumnName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> columnName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleDateFormat <span class="title">getDatePattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datePattern;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;T, String&gt; <span class="title">getConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Excel导出规则builder</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportConvertRuleBuilder</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String columnTitle;<span class="comment">// 列标题</span></span><br><span class="line">        <span class="keyword">private</span> String columnName;<span class="comment">// 列属性值，对应实体属性名</span></span><br><span class="line">        <span class="keyword">private</span> SimpleDateFormat datePattern = <span class="keyword">null</span>;<span class="comment">// 日期输出格式</span></span><br><span class="line">        <span class="keyword">private</span> Map&lt;T, String&gt; converter = <span class="keyword">null</span>; <span class="comment">// 内容替换规则，例如 0:微支付 1:支付宝</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造ExportConvertRule</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> columnTitle</span></span><br><span class="line"><span class="comment">         *            :导出Excel第一行列标题</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> columnName</span></span><br><span class="line"><span class="comment">         *            :导出实体属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExportConvertRuleBuilder</span><span class="params">(String columnTitle, String columnName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.columnTitle = columnTitle;</span><br><span class="line">            <span class="keyword">this</span>.columnName = columnName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 日期格式化规则</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> datePattern</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ExportConvertRuleBuilder&lt;T&gt; <span class="title">setDatePattern</span><span class="params">(SimpleDateFormat datePattern)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.datePattern = datePattern;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 内容转换规则</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> converter</span></span><br><span class="line"><span class="comment">         *            :规则转换map</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ExportConvertRuleBuilder&lt;T&gt; <span class="title">setConverter</span><span class="params">(Map&lt;T, String&gt; converter)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.converter = converter;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回构造实例</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ExportConvertRule&lt;T&gt; <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExportConvertRule&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ExportExcel"><a href="#ExportExcel" class="headerlink" title="ExportExcel"></a>ExportExcel</h2><h3 id="Excel对象描述"><a href="#Excel对象描述" class="headerlink" title="Excel对象描述"></a>Excel对象描述</h3><p>Excle文档可拆分为工作簿、工作表、行、单元格，都被抽象为对应的对象，关系如下：</p><blockquote><p><strong>注意：</strong><br> Excel 07-2003一个工作簿中最多含有255个工作表，一个工作表最多可有65536行，最多可有256列。<br> Excel2007及以后版本，一个工作表最多可有1048576行，16384列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个工作薄</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> XSSFWorkbook workbook = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 生成一个表格</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> XSSFSheet sheet = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 产生表格标题行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> XSSFRow row = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="创建对象："><a href="#创建对象：" class="headerlink" title="创建对象："></a>创建对象：</h3><p>poi提供XSSFWorkbook和HSSFWorkbook两种对象，建议使用<strong>XSSFWorkbook</strong>，支持Excel2007和Excel2003HSSFWorkbook只支持2003。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建工作簿</span></span><br><span class="line"> workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line"> <span class="comment">// 创建并设置工作表名</span></span><br><span class="line">sheet = workbook.createSheet(<span class="string">"工作表名"</span>);  </span><br><span class="line"><span class="comment">// 创建工作表行  </span></span><br><span class="line">row = sheet.createRow(index);  </span><br><span class="line"><span class="comment">// 创建单元格内容</span></span><br><span class="line">XSSFCell cell = row.createCell(i);</span><br><span class="line"><span class="comment">// 设置单元格格式为文本</span></span><br><span class="line">XSSFRichTextString text = <span class="keyword">new</span> XSSFRichTextString(<span class="string">"单元格内容"</span>);</span><br><span class="line">cell.setCellValue(text);</span><br></pre></td></tr></table></figure><h3 id="生成文件内容："><a href="#生成文件内容：" class="headerlink" title="生成文件内容："></a>生成文件内容：</h3><p>获取数据内容：<br>传入数据集合，使用迭代器遍历集合，采用反射的方法，传入属性名控制要输出的字段，遍历javabean对象属性，获取想要输出的字段。<br><strong>设计技巧：</strong>可使用本地缓存，存放反射获取的方法，可极大提升效率，初测可提升至少50%的效率，对于重复率较高的数据，要考虑缓存的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* method的缓存cache */</span></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, Method&gt; methodCache = <span class="keyword">new</span> HashMap&lt;String, Method&gt;();</span><br><span class="line">获取到的内容，需要处理一下，Excle只支持文本和数值，需要处理一下：</span><br><span class="line"><span class="comment">//设置为数值格式</span></span><br><span class="line">cell.setCellType(XSSFCell.CELL_TYPE_NUMERIC); </span><br><span class="line"><span class="comment">//设置为文本格式</span></span><br><span class="line">cell.setCellType(XSSFCell.CELL_TYPE_STRING); </span><br><span class="line">对于日期格式，可格式化为字符串然后输出。</span><br><span class="line"><span class="comment">//若内容为null，使用空内容处理</span></span><br><span class="line">cell.setCellType(XSSFCell.CELL_TYPE_BLANK);  </span><br><span class="line"><span class="comment">//将文件输出到输出流中，支持本地文件导出和web导出</span></span><br><span class="line">workbook.write(out);</span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line">out.flush();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><strong>要点：</strong><br><em>设计模式之建造者模式(Builder)模式</em><br><em>本地缓存使用</em><br><em>优化空间：导出图片功能待开发</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;author:xuejw&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;添加依赖&quot;&gt;&lt;a href=&quot;#添加依赖&quot; class=&quot;headerlink&quot; title=&quot;添加依赖&quot;&gt;&lt;/a&gt;添加依赖&lt;/h2&gt;&lt;p&gt;首先，使用maven添加依赖j
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="工具类" scheme="http://fatesx.gitee.io/blog/categories/java%E5%9F%BA%E7%A1%80/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="1758" scheme="http://fatesx.gitee.io/blog/tags/1758/"/>
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Null是什么？</title>
    <link href="http://fatesx.gitee.io/blog/2018/03/10/010-%E2%80%8BJava%E4%B8%AD%E7%9A%84Null/"/>
    <id>http://fatesx.gitee.io/blog/2018/03/10/010-​Java中的Null/</id>
    <published>2018-03-10T05:23:50.000Z</published>
    <updated>2018-04-09T11:06:05.862Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>author:xuejw(转，有删改)</p></blockquote><p>null是Java中一个很重要的概念。null设计初衷是为了表示一些缺失的东西，例如缺失的用户、资源或其他东西。但是，令人头疼的空指针异常给Java程序员带来不少的骚扰。下面是null关键字的基本细节，并且探索一些技术来尽可能的减少null的检查以及如何避免恶心的空指针异常。</p><h2 id="null是Java中的关键字"><a href="#null是Java中的关键字" class="headerlink" title="null是Java中的关键字"></a>null是Java中的关键字</h2><p>null就像public、static、final,它是大小写敏感的，不能将null写成Null或NULL，编译器将不能识别它们然后报错。<br>使用其他语言的程序员可能会有这个问题，但是现在IDE的使用已经使得这个问题变得微不足道。IDE可以纠正这个错误，但是使用其他工具像notepad、Vim、Emacs，这个问题却会浪费你宝贵的时间。</p><h2 id="null是引用类型的默认值"><a href="#null是引用类型的默认值" class="headerlink" title="null是引用类型的默认值"></a>null是引用类型的默认值</h2><p>就像每种原始类型都有默认值一样，如int默认值为0，boolean的默认值为false，null是任何引用类型的默认值，不严格的说是所有object类型的默认值。就像你创建了一个布尔类型的变量，它将false作为自己的默认值，Java中的任何引用变量都将null作为默认值。这对所有变量都是适用的，如成员变量、局部变量、实例变量、静态变量（但当你使用一个没有初始化的局部变量，编译器会警告你）。为了证明这个事实，你可以通过创建一个变量然后打印它的值来观察这个引用变量，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object myObj;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"What is value of myObjc : "</span> + myObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">What is value of myObjc : <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>这对静态和非静态的object来说都是正确的，将myObj定义为静态引用，所以可以在主方法里直接使用它。<br><strong>注意</strong>：主方法是静态方法，不可使用非静态变量。</p><h2 id="null只是一种值"><a href="#null只是一种值" class="headerlink" title="null只是一种值"></a>null只是一种值</h2><p>null既不是对象也不是一种类型，它仅是一种特殊的值，可以将其赋予任何引用类型，也可以将null转化成任何类型，看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>; <span class="comment">// null can be assigned to String</span></span><br><span class="line">Integer itr = <span class="keyword">null</span>; <span class="comment">// you can assign null to Integer also</span></span><br><span class="line">Double dbl = <span class="keyword">null</span>;  <span class="comment">// null can also be assigned to Double</span></span><br><span class="line"> </span><br><span class="line">String myStr = (String) <span class="keyword">null</span>; <span class="comment">// null can be type cast to String</span></span><br><span class="line">Integer myItr = (Integer) <span class="keyword">null</span>; <span class="comment">// it can also be type casted to Integer</span></span><br><span class="line">Double myDbl = (Double) <span class="keyword">null</span>; <span class="comment">// yes it's possible, no error</span></span><br></pre></td></tr></table></figure><p>可以看到在编译和运行时期，将null强制转换成任何引用类型都是可行的，在运行时期都不会抛出空指针异常。</p><h2 id="null只能赋值给引用变量"><a href="#null只能赋值给引用变量" class="headerlink" title="null只能赋值给引用变量"></a>null只能赋值给引用变量</h2><p>不能将null赋给基本类型变量，例如int、double、float、boolean。如果那样做了，编译器将会报错，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="keyword">null</span>; <span class="comment">// type mismatch : cannot convert from null to int</span></span><br><span class="line"><span class="keyword">short</span> s = <span class="keyword">null</span>; <span class="comment">//  type mismatch : cannot convert from null to short</span></span><br><span class="line"><span class="keyword">byte</span> b = <span class="keyword">null</span>: <span class="comment">// type mismatch : cannot convert from null to byte</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="keyword">null</span>; <span class="comment">//type mismatch : cannot convert from null to double</span></span><br><span class="line"> </span><br><span class="line">Integer itr = <span class="keyword">null</span>; <span class="comment">// this is ok</span></span><br><span class="line"><span class="keyword">int</span> j = itr; <span class="comment">// this is also ok, but NullPointerException at runtime</span></span><br></pre></td></tr></table></figure></p><p>正如上面看到的那样，当直接将null赋值给基本类型，会出现编译错误。但是如果将null赋值给包装类object，然后将object赋给各自的基本类型，编译器不会报，但是将会在运行时期遇到空指针异常。这是Java中的自动拆箱导致的.。</p><h2 id="自动装箱不会将null转换成各自基本类型的默认值"><a href="#自动装箱不会将null转换成各自基本类型的默认值" class="headerlink" title="自动装箱不会将null转换成各自基本类型的默认值"></a>自动装箱不会将null转换成各自基本类型的默认值</h2><p>任何含有null值的包装类在Java拆箱生成基本数据类型时候都会抛出一个空指针异常，事例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer iAmNull = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> i = iAmNull; <span class="comment">// Remember - No Compilation Error</span></span><br></pre></td></tr></table></figure><p>但是当运行上面的代码片段的时候，会在控制台上看到主线程抛出空指针异常。<br>在使用HashMap和Integer键值的时候会发生很多这样的错误，例如运行下面代码的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      Map numberAndCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span>[] numbers = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>,<span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i : numbers)&#123;</span><br><span class="line">         <span class="keyword">int</span> count = numberAndCount.get(i);</span><br><span class="line">         numberAndCount.put(i, count++); <span class="comment">// NullPointerException here</span></span><br><span class="line">      &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException at Test.main(Test.java:<span class="number">25</span>)</span><br></pre></td></tr></table></figure><p>这段代码看起来非常简单并且没有错误。代码只是找到一个数字在数组中出现了多少次，这是Java数组中典型的寻找重复的技术。首先得到以前的数值，然后再加一，最后把值放回Map里。调用put方法时，自动装箱不会自己处理好将int装箱成Interger，当一个数字没有计数值的时候，HashMap的get()方法将会返回null，而不是0，因为Integer的默认值是null而不是0。当把null值传递给一个int型变量的时候自动装箱将会返回空指针异常。</p><h2 id="引用类型值为null，instanceof操作将会返回false"><a href="#引用类型值为null，instanceof操作将会返回false" class="headerlink" title="引用类型值为null，instanceof操作将会返回false"></a>引用类型值为null，instanceof操作将会返回false</h2><p>示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer iAmNull = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(iAmNull <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">   System.out.println(<span class="string">"iAmNull is instance of Integer"</span>);                             </span><br><span class="line"> </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"iAmNull is NOT an instance of Integer"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iAmNull is NOT an instance of Integer</span><br></pre></td></tr></table></figure></p><p>这是instanceof操作一个很重要的特性，使得对类型强制转换检查很有用。</p><h2 id="可以使用静态方法来使用一个值为null的引用类型变量"><a href="#可以使用静态方法来使用一个值为null的引用类型变量" class="headerlink" title="可以使用静态方法来使用一个值为null的引用类型变量"></a>可以使用静态方法来使用一个值为null的引用类型变量</h2><p>不能调用非静态方法来使用一个值为null的引用类型变量。它将会抛出空指针异常，但是可以使用静态方法来使用一个值为null的引用类型变量。因为静态方法使用静态绑定，不会抛出空指针异常。下面是一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testing</span> </span>&#123;            </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Testing myObject = <span class="keyword">null</span>;</span><br><span class="line">      myObject.iAmStaticMethod();</span><br><span class="line">      myObject.iAmNonStaticMethod();                            </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iAmStaticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am static method, can be called by null reference"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">iAmNonStaticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"I am NON static method, don't date to call me by null"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am <span class="keyword">static</span> method, can be called by <span class="keyword">null</span> reference</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerExceptionat Testing.main(Testing.java:<span class="number">11</span>)</span><br></pre></td></tr></table></figure></p><h2 id="将null传递给方法"><a href="#将null传递给方法" class="headerlink" title="将null传递给方法"></a>将null传递给方法</h2><p>这时方法可以接收任何引用类型，例如public void print(Object obj)，可以这样调用print(null)。从编译角度来看这是可以的，但结果完全取决于方法。Null安全的方法，如在这个例子中的print方法，不会抛出空指针异常，只是优雅的退出。如果业务逻辑允许的话，推荐使用null安全的方法。</p><h2 id="null的比较"><a href="#null的比较" class="headerlink" title="null的比较"></a>null的比较</h2><p>可以使用==或者!=操作来比较null值，但是不能使用其他算法或者逻辑操作，例如小于或者大于。在Java中null==null将返回true，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">       String abc = <span class="keyword">null</span>;</span><br><span class="line">       String cde = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span>(abc == cde)&#123;</span><br><span class="line">           System.out.println(<span class="string">"null == null is true in Java"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">null</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">"null != null is false in Java"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// classical null check</span></span><br><span class="line">       <span class="keyword">if</span>(abc == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">// do something</span></span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// not ok, compile time error</span></span><br><span class="line">       <span class="keyword">if</span>(abc &gt; <span class="keyword">null</span>)&#123;</span><br><span class="line"> </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span> == <span class="keyword">null</span> is <span class="keyword">true</span> in Java</span><br></pre></td></tr></table></figure><p>以上是关于Java中null的全部。通过Java编程的一些经验和使用简单的技巧来避免空指针异常，可以使得代码变得null安全。因为null经常作为空或者未初始化的值，它是困惑的源头。对于方法而言，记录下null作为参数时方法有什么样的行为也是非常重要的。<br><strong>总而言之，null是任何一个引用类型变量的默认值，在java中不能使用null引用来调用任何的instance方法或者instance变量。</strong></p><blockquote><p>参考：<br>原文链接： javarevisited 翻译： ImportNew.com - Calarence<br>译文链接： <a href="http://www.importnew.com/14229.html" target="_blank" rel="noopener">http://www.importnew.com/14229.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;author:xuejw(转，有删改)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;null是Java中一个很重要的概念。null设计初衷是为了表示一些缺失的东西，例如缺失的用户、资源或其他东西。但是，令人头疼的空指针异常给Java程序员带来不少的骚
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="1758" scheme="http://fatesx.gitee.io/blog/tags/1758/"/>
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多线程之ThreadLocal</title>
    <link href="http://fatesx.gitee.io/blog/2018/03/03/03-ThreadLocal/"/>
    <id>http://fatesx.gitee.io/blog/2018/03/03/03-ThreadLocal/</id>
    <published>2018-03-03T05:23:50.000Z</published>
    <updated>2018-04-09T11:06:43.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h2><p>创建线程，通常用两种方式：</p><p>早在JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p><p>ThreadLocal很容易让人望文生义，想当然地认为是一个“本地线程”。其实，ThreadLocal并不是一个Thread，而是Thread的局部变量，也许把它命名为ThreadLocalVariable更容易让人理解一些。</p><p>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。<br>从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。</p><p>线程局部变量并不是Java的新发明，很多语言（如IBM IBM XL FORTRAN）在语法层面就提供线程局部变量。在Java中没有提供在语言级支持，而是变相地通过ThreadLocal的类提供支持。<br>所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。</p><h2 id="ThreadLocal的接口方法"><a href="#ThreadLocal的接口方法" class="headerlink" title="ThreadLocal的接口方法"></a>ThreadLocal的接口方法</h2><p>ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object value)</span></span></span><br></pre></td></tr></table></figure><p>设置当前线程的线程局部变量的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>该方法返回当前线程所对应的线程局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p><p>值得一提的是，在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal<t>。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。</t></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。我们自己就可以提供一个简单的实现版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单1 SimpleThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThreadLocal</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map valueMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object newValue)</span> </span>&#123;</span><br><span class="line">        valueMap.put(Thread.currentThread(), newValue);①键为线程对象，值为本线程的变量副本</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        Object o = valueMap.get(currentThread);②返回本线程对应的变量</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> &amp;&amp; !valueMap.containsKey(currentThread)) &#123;③如果在Map中不存在，放到Map</span><br><span class="line">            中保存起来。</span><br><span class="line">            o = initialValue();</span><br><span class="line">            valueMap.put(currentThread, o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        valueMap.remove(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面，我们通过一个具体的实例了解一下ThreadLocal的具体使用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceNumber</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; seqNum = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取下一个序列值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        seqNum.set(seqNum.get()+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> seqNum.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SequenceNumber sn = <span class="keyword">new</span> SequenceNumber();</span><br><span class="line"></span><br><span class="line">        <span class="number">3</span>个线程共享sn，各自产生序列号</span><br><span class="line">        TestClient t1 = <span class="keyword">new</span> TestClient(sn);</span><br><span class="line">        TestClient t2 = <span class="keyword">new</span> TestClient(sn);</span><br><span class="line">        TestClient t3 = <span class="keyword">new</span> TestClient(sn);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> <span class="keyword">extends</span> <span class="title">Thread</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SequenceNumber sn;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestClient</span><span class="params">(SequenceNumber sn)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sn = sn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;④每个线程打出<span class="number">3</span>个序列值</span><br><span class="line">                System.out.println(<span class="string">"thread["</span>+Thread.currentThread().getName()+ <span class="string">"] sn["</span>+sn.getNextNum()+<span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DateFormat、DecimalFormat等是非线程安全的，因此可使用ThreadLocal进行改造。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ThreadLocal是什么&quot;&gt;&lt;a href=&quot;#ThreadLocal是什么&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal是什么&quot;&gt;&lt;/a&gt;ThreadLocal是什么&lt;/h2&gt;&lt;p&gt;创建线程，通常用两种方式：&lt;/p&gt;
&lt;p&gt;早
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="http://fatesx.gitee.io/blog/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="1758" scheme="http://fatesx.gitee.io/blog/tags/1758/"/>
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多线程之Callable接口</title>
    <link href="http://fatesx.gitee.io/blog/2018/03/02/02-Callable/"/>
    <id>http://fatesx.gitee.io/blog/2018/03/02/02-Callable/</id>
    <published>2018-03-02T05:23:50.000Z</published>
    <updated>2018-04-09T11:07:29.272Z</updated>
    
    <content type="html"><![CDATA[<p>创建线程，通常用两种方式：</p><p>1、<code>直接继承Thread</code>；</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class BroadcastThread extends Thread&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//process</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方式：</span></span><br><span class="line">Thread broadcastThread = <span class="keyword">new</span> BroadcastThread();<span class="comment">//创建群发线程</span></span><br><span class="line">broadcastThread.start();<span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure><p>2、<code>实现Runnable接口</code></p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class BroadcastThread implements Runnable&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//process</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用方式：</span><br><span class="line">Thread broadcastThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BroadcastThread());<span class="comment">//创建群发线程</span></span><br><span class="line">broadcastThread.start();<span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure><p>请注意，这两种方式调用的缺点——均没有返回值，因此意味着线程在执行完任务之后无法获取执行结果。</p><p>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，使用起来比较麻烦。</p><p>而从Java 1.5开始，开始提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果，极大方便线程的处理。</p><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Class FetchUgcThread implements Callable&lt;Ugc&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Ugc <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//process</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);<span class="comment">//模拟一个耗时操作（5秒）</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Ugc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建FutureTask的callable执行对象</span></span><br><span class="line">FutureTask&lt;Ugc&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Ugc&gt;(<span class="keyword">new</span> FetchUgcThread());</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">thread.start();<span class="comment">//启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为子线程执行时长为5秒，因此可在此处进行主线程的后续操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取callable线程的运行结果，在返回数据前（5秒），线程会一直block</span></span><br><span class="line"><span class="comment">//为了避免主线程等候，通常建议把该方法放在代码块最后执行</span></span><br><span class="line">Ugc ugc = futureTask.get();</span><br></pre></td></tr></table></figure><p>PS: 上面的启动线程，亦可使用线程池方式进行提交。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>使用Callable的方式，对for循环方式获取ugc进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;FutureTask&gt; taskList = <span class="keyword">new</span> ArrayList&lt;FutureTask&gt;();<span class="comment">//构造一个list容器，存放各任务的FutureTask对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;<span class="comment">//获取10个ugc信息</span></span><br><span class="line">    </span><br><span class="line">    FutureTask&lt;Ugc&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Ugc&gt;(<span class="keyword">new</span> FetchUgcThread());</span><br><span class="line">    taskList.add(futureTask);<span class="comment">//将任务对象添加到list容器中</span></span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">    thread.start();<span class="comment">//启动线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程的其他业务处理</span></span><br><span class="line"></span><br><span class="line">List&lt;Ugc&gt; ugcList = ArrayList&lt;Ugc&gt;();</span><br><span class="line"><span class="keyword">for</span>(FutureTask task: taskList)&#123;<span class="comment">//获取taskList的执行结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取线程的执行结果，并添加到列表容器中</span></span><br><span class="line">    Ugc ugc = task.get();</span><br><span class="line">    ugcList.add(ugc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据处理&amp;返回</span></span><br><span class="line"><span class="keyword">return</span> ugcList;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用Callable方式对for循环进行优化，可将for循环方式的同步方式调用，变更为多线程方式调用。对于需要循环遍历，获取复杂数据的场景下，能大幅提升执行效率。</p><p>另外，也可配合<a href="./CountDownLatch.md">CountDownLatch</a>来使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建线程，通常用两种方式：&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;直接继承Thread&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="http://fatesx.gitee.io/blog/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="1758" scheme="http://fatesx.gitee.io/blog/tags/1758/"/>
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>多线程之CountDownLatch</title>
    <link href="http://fatesx.gitee.io/blog/2018/03/01/01-CountDownLatch/"/>
    <id>http://fatesx.gitee.io/blog/2018/03/01/01-CountDownLatch/</id>
    <published>2018-03-01T05:23:50.000Z</published>
    <updated>2018-04-09T11:06:22.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>前段时间，使用CountDownLatch，对微社区中获取帖子列表的操作，进行了优化，优化数据如下：</p><p>原处理方式，平均时长为400~600ms左右; 优化后，平均时长为200ms左右，性能提升一倍。</p><p>在此介绍如下：</p><p>CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定计数的次数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>主要方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数减1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待，调用此方法会一直阻塞当前线程，直到计时器的值为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待指定的时长，超过后则解除阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>以微社区中的获取ugc列表功能为例：<a href="http://wx.1758.com/game/h5/newsfeed.htm" target="_blank" rel="noopener">点击查看</a></p><h4 id="在获取ugc列表时，原方案如下："><a href="#在获取ugc列表时，原方案如下：" class="headerlink" title="在获取ugc列表时，原方案如下："></a>在获取ugc列表时，原方案如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ugcPostIdList = getUgcPostId(pageNo, pageSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Integer ugcPostId: ugcPostIdList)&#123;</span><br><span class="line">     populateUgcPostInfo(userId, ugcPostId);<span class="comment">//for循环方式组装主题贴资料</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的populateUgcPostInfo方法，因操作内容较多（（发帖人信息、所属游戏的信息，回帖内容&amp;回帖人列表、赞列表）比较耗时。<br>而for循环中，耗时时间则进一步放大，因为要便利执行同样的n次操作，耗时更长。</p><h4 id="优化方案："><a href="#优化方案：" class="headerlink" title="优化方案："></a>优化方案：</h4><p>使用CountDownLatch，获取ugc列表时，将for循环方式获取主题贴资料，改为多线程方式获取。</p><p>即同时发起n个获取ugc主贴的线程，当其中最后一个线程完成时（或超过await的时间限制），主线程才继续向下进行。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ugcPostIdList = getUgcPostId(pageNo, pageSize);</span><br><span class="line"><span class="comment">//构造CountDownLatch对象</span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(ugcPostIdList.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造FutureTask列表</span></span><br><span class="line">List&lt;FutureTask&lt;WyCommonComment&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;FutureTask&lt;WyCommonComment&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Integer ugcPostId: ugcPostIdList)&#123;</span><br><span class="line">     <span class="comment">//启动线程组装主题贴资料</span></span><br><span class="line">     FutureTask&lt;WyCommonComment&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;WyCommonComment&gt;(<span class="keyword">new</span> FetchUgcPostThread(countDownLatch, ugcPostId));</span><br><span class="line">     futureList.add(futureTask);<span class="comment">//任务列表中增加对象</span></span><br><span class="line">     <span class="keyword">new</span> Thread(futureTask).start();<span class="comment">//运行线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     countDownLatch.await(<span class="number">3</span>, TimeUnit.SECONDS);<span class="comment">//阻塞等待3秒</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理多线程处理的任务</span></span><br><span class="line"><span class="keyword">if</span>(futureList!=<span class="keyword">null</span>)&#123;</span><br><span class="line">     <span class="keyword">for</span>(FutureTask&lt;WyCommonComment&gt; futureTask: futureList)&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">               WyCommonComment result = futureTask.get();</span><br><span class="line">               <span class="keyword">if</span>(result!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    ugcList.add(result);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ugcList;</span><br></pre></td></tr></table></figure><p>线程对象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Callable，注意与Runnable的区别</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchUgcPostThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">WyCommonComment</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">     <span class="keyword">private</span> String ugcIdStr;</span><br><span class="line">     <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">FetchUgcPostThread</span><span class="params">(CountDownLatch countDownLatch, String ugcIdStr, Long userId)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">super</span>();</span><br><span class="line">          <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">          <span class="keyword">this</span>.ugcIdStr = ugcIdStr;</span><br><span class="line">          <span class="keyword">this</span>.userId = userId;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> WyCommonComment <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         </span><br><span class="line">          WyCommonComment ugcPostInfo = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">               <span class="keyword">long</span> ugcPostId = NumberUtils.toLong(ugcIdStr, <span class="number">0l</span>);</span><br><span class="line">               <span class="keyword">if</span>(ugcPostId&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    ugcPostInfo = populateUgcPostInfo(userId, ugcPostId);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">               countDownLatch.countDown();<span class="comment">//异常情况下，也要确保完成计数</span></span><br><span class="line">          &#125;</span><br><span class="line">  <span class="comment">//返回处理结果</span></span><br><span class="line">          <span class="keyword">return</span> ugcPostInfo;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果对比"><a href="#结果对比" class="headerlink" title="结果对比"></a>结果对比</h4><p>测试方法：获取10个ugc主贴</p><p>原处理方式，平均时长为400~600ms左右。</p><p>优化后，平均时长为200ms左右。</p><p>性能提升一倍。</p><h3 id="其他优化空间"><a href="#其他优化空间" class="headerlink" title="其他优化空间"></a>其他优化空间</h3><p>线程池</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>CountDownLatch</p><p>Callable</p><p>FutureTask</p><p>线程池</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;p&gt;前段时间，使用CountDownLatch，
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/categories/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="http://fatesx.gitee.io/blog/categories/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="1758" scheme="http://fatesx.gitee.io/blog/tags/1758/"/>
    
      <category term="java基础" scheme="http://fatesx.gitee.io/blog/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://fatesx.gitee.io/blog/2018/02/26/hello-world/"/>
    <id>http://fatesx.gitee.io/blog/2018/02/26/hello-world/</id>
    <published>2018-02-26T02:44:36.862Z</published>
    <updated>2018-02-26T02:44:36.863Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
